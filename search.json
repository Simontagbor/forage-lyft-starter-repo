[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "",
    "text": "Let’s begin by looking at the context of the problem and the existing codebase."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "index.html#situation",
    "href": "index.html#situation",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Situation",
    "text": "Situation\n\nI inherited a codebase from a previous engineer who started working on a new system for managing the maintenance of the types of vehicles in LYFT’s rental fleet. The previous engineer had to be assigned to another project. As a junior backend engineer, I was tasked to build on his existing work\n\n\nFrom an Object Oriented Program design perspective, the codebase left behind by the engineer is not easily extensible and maintainable. The design relies almost entirely on inheritance to model vehicles in LYFT’s rental fleet, complete with their servicing criteria.\n\n\nConsequently, the codebase has been riddled with components that have deep inheritance hierarchies. Servicing criteria may change frequently as LYFT’s rental fleet evolves. Introducing new updates in the current codebase will require making changes to many parts of the codebase, thereby increasing the chances of introducing several time-consuming bugs while also running the risk of duplicating code\n\n\nEven more so, the codebase lacks unit tests with extensive coverage. LYFT fleet management system would be better off with a new and extensively tested design of the backend business logic"
  },
  {
    "objectID": "index.html#tasks",
    "href": "index.html#tasks",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Tasks",
    "text": "Tasks\n\nFor this project, I completed the following tasks:\n\n\n\nTask 1: Re-designed backend Business Logic for Fleet Management System. ✅\n\n\nTask 2: Refactored and Optimized Codebase ✅\n\n\nTask 3: Wrote Extensive Unittests ✅\n\n\nTask 4: Implement a New Tire Servicing Criteria. ✅"
  },
  {
    "objectID": "index.html#actions",
    "href": "index.html#actions",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Actions",
    "text": "Actions\n\n1. Backend Business Logic Re-Design\n\nDesign Challenges With The Existing Codebase\n\n\nAs can be seen from the above UML diagram, The Previous Engineer used a convoluted inheritance hierarchy to handle the different types of vehicles in the fleet.\n\nThe Engineer created different car models in LYFT’s fleet by subclassing three unique engine types which are also by themselves, an extension of Car and ABC parent classes.\n\n\nThe 3 Key Pain Points Identified in the Existing Codebase:\n\n\n\n\n\nDifficulty in adding new vehicle types to the fleet.\n\n\n\n\n\nManaging Variations in Vehicle Features will be Cumbersome.\n\n\n\n\n\nConvoluted Inheritance Hierarchy makes the codebase tightly coupled\n\n\n\n\nFinding Solutions\n\n\nAfter gathering enough details about the goals of the fleet management system and familiarising myself with the codebase, I looked into design patterns that could help address the key design challenges.\n\n\n\n\n\nI used a combination of design patterns and object-oriented program design principles to sanitize the codebase. The thought process behind the design choices is further discussed below:\n\n\n\n\n\nStrategy Design Pattern\n\n\n\n\nStrategy Design Pattern\n\nThis design pattern choice felt more natural for instances where we will be handling different vehicles with unique algorithms for determining servicing needs. A typical strategy design pattern approach would involve creating a Serviceable interface - an abstract class of anything that can be serviced with a needs_service abstract method. Different Car subclasses of the interface would then encapsulate their own needs_service algorithms for determining when its instances should be serviced.\n\n\nThe strategy design pattern makes it more straightforward to add new vehicles and it also ensures that each new Car variant has its own strategy for determining servicing needs implemented. For instance, LYFT may decide in the future to add a Motorbike and Segway to its fleet. The Serviceable interface makes it easier to extend the codebase to meet the new requirements with fewer breaking changes. You can read more about about The strategy design pattern Here\n\n\n\n\n\n\n\n\nFactory Design Pattern\n\n\n\n\nFactory Design Pattern\n\nConsidering that our fleet management system will be instantiating several vehicle types across the codebase, it will be helpful to use a creational design parttern to organize the logic of how vehicles in the fleet get created in one place. Similar to other creational design patterns, the factory design pattern attempts to encapsulate the logic for creating variants of Car instances in one well-defined CarFactory class interface.\n\n\nThis approach abstracts how a Car instance gets created, making it possible to isolate the client from having to know how the instances get “assembled”. For example, if the specification requires that a Calliope car object should have a particular Engine, Battery and Tire components, the CarFactory interface will provide a .create_calliope_car(…) public method that puts the right components together and returns a calliope car object to the client.\n\nThe factory design pattern allows for a much cleaner codebase and any problem with our object creation logic can be easily isolated during debugging because now the creation of objects is independent of the client that uses them. you can learn more about the Factory Design Pattern here\n\n\n\n\n\n\n\n\nComposition Over Inheritance\n\n\n\n\nComposition Over Inheritance\n\nI used the design principle of “composition over inheritance” to address the pain point of complex and deep inheritance hierarchy in the codebase. In the current design, components are too tightly coupled making the codebase less modular. favoring composition - where we create a complete unit of components(also known as composites) that are independent of other components and assign them as attributes of a class that depends on them.\n\n\nFor example cars in LYFT’s fleet will need to have Engine and Battery components to determine servicing needs. The inheritance approach would be to let the Car class subclass Engine and Battery classes. This way, the car instances would have all the attributes they need to determine servicing needs. This approach is not only error-prone, it also results in duplicated code.\n\nWith composition, we simply treat Engine and Battery as independent classes that can be used by other classes as shown by the Car class below:\n\nimport Engine\nimport Battery\n\nclass Car(Serviceable):\n    ....\n    def __init__(self, engine: Engine, battery: Battery):\n        self.engine = engine \n        self.battery = battery\n\nFor our use case, not only does choosing to favor composition over inheritance make the codebase more modular, but it also makes the design more intuitive as it models the real-world relationships between a car and its components. It feels more natural to say a Car HAS A Battery and an Engine than it is to say a Car IS A Battery and an Engine combined. You can learn more about the principle here: Inheritance and Composition\n\n\n\n\n\n\nAfter these considerations I used the UML diagram to propose the new design changes. The final design was submitted for review and approval. The UML diagram below shows the proposed changes to the codebase.\n\n\n\nAfter Backend Logic Redesign\n\n\n\n\n2. Codebase Refactoring\n\nAfter sharing the new design and getting the green light to implement it, I refactored the codebase based on the new design.\n\n\nThe new codebase has the following updates:\n\n\nNew Directory Structure After Refactoring\n\nI restructured the codebase to make it more organized and maintainable. The new directory structure is as follows:\n\n├── .\n│   ├── serviceable.py\n│   ├── car.py\n│   ├── car_factory.py\n│   ├── .gitingore\n│   ├── README.md\n|   ├── battery\n|   |   |── __init__.py\n|   |   ├── base_battery.py\n|   |   ├── spindler_battery.py\n|   |   ├── nubbin_battery.py\n|   ├── engine\n|   |   |── __init__.py\n|   |   ├── base_engine.py\n|   |   ├── capulet_engine.py\n|   |   ├── wiloughby_engine.py\n|   |   |── sternman_engine.py\n|   ├── test\n|   |   ├── __init__.py\n|   |   ├── test_car.py\n|   ├── utils\n|   |   |── __init__.py\n|   |   ├── input_validator.py\n\nThe new structure is now more organized and maintainable.\n\n\nBased on the Factory Method Pattern, We will not need to create new models to represent new fleets of cars. We can simply create a new class that inherits from the base class and implement the methods that are specific to the new fleet of cars. we will no longer need the /engine/models/ directory where these specialized car models were defined.\n\n\nThe new structure also includes:\n\n\n\n\nA battery directory to define battery components for car objects.\nA utils directory to define input validation and other helper functions for creating components and cars.\nRemoval of the engine/model directory.\nUpdated engine directory files to reflect the new design.\nA car.py module to reflect the new design.\nA car_factory.py module to leverage the factory method and strategy design patterns.\nA serviceable.py module to define an interface for different types of vehicles.\n\n\n\n\n3. Extensive Unit testing of the Codebase\nI wrote unit tests to test the new codebase. The unit tests are located in the test directory. The unittests cover the following:\n\n\nTest the creation of different types of vehicles. ✅\n\n\nTest the creation of different types of engines. ✅\n\n\nTest the creation of different types of batteries. ✅\n\n\nTest that the Car class is correctly implemented. ✅\n\n\nTest that the Base Engine and Base Battery classes are correctly implemented. ✅\n\n\nTest that the derived classes from the Base Engine and Base Battery classes are correctly implemented. ✅\n\n\nTest the input validation for creating components and cars. ✅\n\n\n\nTesting Approach\n\nI mostly wrote standard unit tests, however, in some cases I used @patchdecorator to mock the creation of different types of vehicles, engines, and batteries using the Factory Method Pattern- Implemented Via the car_factory.py module. I did that to ensure that the tests are independent of the client that uses them.\n\n\nMocking the creation of objects allowed me to focus on testing the functionality of the code in isolation, without relying on the specific details of the instantiated objects.\n\n\n\nTest Coverage\n\n\n\nTest Coverage Report by coverage Python package\n\n\n\nsee the full test coverage report here\n\n\nIn total, the code coverage is about 99% and all tests 71 tests passed. The only module not tested is the serviceable.py which is an interface for serviceable objects like cars. I can safely assume that the interface is correctly implemented since all the derived classes from the interface are acting as expected.\n\npython3 -m unittest -v\n\n\n\nResults from Running Uittest in Verbose mode\n\n\n\n\n\nTask 4 - Implement New Tire Servicing Criteria\n\nNow that the codebase is more maintainable and scalable, I implemented new tire servicing criteria. However, I used the Test-Driven Development (TDD) approach to implement the new tire servicing criteria.\n\n\nTest-Driven Development (TDD) Approach\n\nTest-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first, the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.\n\n\nMy Steps\n\n\nUpdate the test_car.py module to include a new test case for the new tire servicing criteria.\n\n\nAdd new tests for tire objects and tire servicing criteria.\n\n\nRun the tests to ensure that the new tests fail.\n\n\nImplement the new tire servicing criteria in the car.py module by ensuring that the car class has tire attributes. Implement tire-related classes and tire servicing criteria in the tire directory.\n\n\nRun the tests to ensure that the new tests pass."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Results",
    "text": "Results\n\nAfter completing the tasks, I achieved the following results:\n\n\n\nResults\n\n\n\n\nThe backend Business Logic for the Fleet Management System is now Modular and Scalable. ⭐\n\n\nThe codebase now has a test coverage of 99%. ⭐\n\n\nThe new tire servicing criteria were implemented and tested to spec. ⭐\n\n\nThe codebase is now well documented to improve collaboration with other developers. ⭐\n\n\n\n\n\nSanitized Codebase at a Glance\n├── .\n│   ├── serviceable.py\n│   ├── car.py\n│   ├── car_factory.py\n│   ├── .gitingore\n│   ├── README.md\n|   ├── battery\n|   |   |── __init__.py\n|   |   ├── base_battery.py\n|   |   ├── spindler_battery.py\n|   |   ├── nubbin_battery.py\n|   ├── engine\n|   |   |── __init__.py\n|   |   ├── base_engine.py\n|   |   ├── capulet_engine.py\n|   |   ├── wiloughby_engine.py\n|   |   |── sternman_engine.py\n|   ├── tire\n|   |   |── __init__.py\n|   |   ├── base_tire.py\n|   |   ├── carrigan_tire.py\n|   |   ├── octo_prime_tire.py\n|   ├── test\n|   |   ├── __init__.py\n|   |   ├── test_battery\n|   |   |   ├── test_battery.py\n|   |   ├── test_car\n|   |   |   ├── __init__.py\n|   |   |   ├── test_car.py\n|   |   |   ├── test_car_factory.py\n|   |   ├── test_engine\n|   |   |   ├── __init__.py\n|   |   |   ├── test_engine.py\n|   |   ├── test_tire\n|   |   |   ├── __init__.py\n|   |   |   ├── test_tire.py\n|   |   ├── test_utils\n|   |   |   ├── __init__.py\n|   |   |   ├── test_input_validator.py\n|   ├── utils\n|   |   |── __init__.py\n|   |   ├── input_validator.py"
  },
  {
    "objectID": "index.html#key-learning-outcomes",
    "href": "index.html#key-learning-outcomes",
    "title": "What I learned as a Junior Backend Software Engineer at Lyft - A Forage Job Simulation Experience",
    "section": "Key Learning Outcomes",
    "text": "Key Learning Outcomes\n\nI enjoyed working on this project and learned a lot about the following:\n\n\n\n\nDesign Patterns: I learned about different design patterns such as the Factory Method Pattern and Strategy Pattern. I learned how to use these patterns to create a more scalable and maintainable codebase. I will always have it in mind that different design patterns can be used to solve different problems and understanding the problem domain is key to choosing the right design pattern.\n\n\n\n\nTest-Driven Development (TDD): having known about the concept for a while, I finally got to use it in my workflow as a developer. I saw firsthand that TDD is a great way to ensure that the code is working as expected and to catch bugs early in the development process.\n\n\n\n\nUnit Testing: I reinforced my understanding of unit testing techniques and I am now committed to writing extensive unit tests in future projects. I also learned how to use the @patch decorator from the unittest module to mock the creation of objects. I also discovered a neat way to measure the coverage of tests inside the codebase using the coverage package.\n\n\n\n\nFeel free to reach out to me on X or LinkedIn if you have any questions or feedback about this project. I would love to hear from you."
  }
]